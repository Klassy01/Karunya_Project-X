Module 5: Graphical User Interface (GUI) Development

5.1 Introduction to GUI Programming

-Overview of AWT, Swing, and JavaFX

Java provides three GUI frameworks, each evolving over time:

AWT (1995): Heavyweight, uses OS-native components, limited customization.

Swing (1997): Lightweight, supports MVC architecture, provides JFrame, JPanel, JButton.

JavaFX (2011): Modern UI toolkit, supports CSS, animations, WebView, FXML.

Threading considerations: GUI updates must run on the Event Dispatch Thread (EDT).

JavaFX vs. Swing: JavaFX supports hardware acceleration, making it more efficient.

Migration: Swing applications can be integrated with JavaFX via JFXPanel.

-Event-Driven Programming

Java follows a delegation-based event model where:

Events are generated by components (JButton, JTextField).

Listeners (Observer Pattern) handle these events (ActionListener, KeyListener).

EventObject encapsulates event details.

EventQueue ensures thread-safe event processing.

Swing’s EDT (Event Dispatch Thread) prevents race conditions in UI updates.

5.2 Building User Interfaces with Swing

-Creating Windows with JFrame

JFrame is the top-level container that provides window functionality in Swing.

Uses BorderLayout by default.

Event-driven: Requires listeners for user interactions.

GUI runs on EDT (Event Dispatch Thread) for thread safety.

Supports custom look and feel through UIManager.

-Adding Components (Buttons, TextFields, Labels)

Swing provides lightweight UI components built on JComponent.

Buttons trigger actions via ActionListener.

Labels provide text but do not support user input.

Text fields generate ActionEvent when pressing Enter.

-Layout Managers

Swing layout managers enable responsive UI designs:

BoxLayout aligns components vertically/horizontally.

GridBagLayout provides flexible grid-based positioning.

Default Layouts: JPanel uses FlowLayout, JFrame uses BorderLayout.

-Event Handling and Listeners

Java’s Event Delegation Model separates event generation from handling.

Listeners must be registered using .addActionListener().

Supports anonymous inner classes and lambda expressions.

5.3 Advanced Swing Components

-Menus and Toolbars

Java Swing supports menu-driven interfaces using:

Menu Components: JMenuBar, JMenu, JMenuItem, JCheckBoxMenuItem, JRadioButtonMenuItem.

Event Handling: Menu items trigger actions via ActionListener.

Nested Menus: Menus can have submenus (JMenu.add(JMenuItem)).

Toolbars (JToolBar): Dockable UI elements containing buttons, icons, or actions.

Accelerators (setAccelerator()): Assign keyboard shortcuts like Ctrl + S for Save.

Custom rendering: Allows icons, colors, and fonts in menu items

-Dialogs and Pop-ups

Swing uses modal and non-modal dialogs:

JOptionPane: Simplified API for message pop-ups.

JDialog: Fully customizable dialogs with embedded components.

Modal vs. Non-Modal:

Modal: Blocks interaction with other windows (setModal(true)).

Non-Modal: Allows users to interact with other windows.

Event Handling: Dialogs trigger actions via ActionListener and WindowListener.

Custom Dialogs: Extend JDialog to create application-specific pop-ups.

-Tables and Trees

Java Swing offers flexible data structures for visualization:

JTable: Uses TableModel to manage data dynamically.

Cell Rendering: TableCellRenderer customizes cell appearance.

Column Resizing: Users can adjust column widths dynamically.

JTree: Implements the Composite design pattern for hierarchical structures.

Tree Selection: TreeSelectionListener detects user interactions.

Tree Expansion Handling: TreeExpansionListener manages expanded/collapsed nodes.



5.4 JavaFX Overview

-Setting Up JavaFX

JavaFX setup involves configuring environment variables and IDE settings:

Manual Setup: Download JavaFX SDK, extract files, and configure the PATH.

IDE Integration:

IntelliJ IDEA: Set JavaFX SDK in project libraries.

Eclipse: Install JavaFX plugin and link SDK.

Gradle/Maven Dependencies: Use org.openjfx for automatic setup.

JavaFX Launcher (Application class): start(Stage primaryStage) initializes the UI.

Gluon JDK: Provides pre-bundled JavaFX support for cross-platform development.



-Building UI with FXML

FXML supports declarative UI design using XML syntax:

Hierarchy Structure: Nested elements define UI layout (<HBox>, <VBox>, <BorderPane>).

Controller Class Binding: Uses fx:id to connect UI components with Java.

Event Handlers: Defined in FXML (onAction="#handleClick") and linked to methods in Java.

Dynamic UI Loading: FXMLLoader supports lazy loading of components.

Dependency Injection: Supports automatic binding via @FXML annotations.

FXML Validation: Ensures XML syntax correctness with JavaFX Scene Builder.

-Styling with CSS

JavaFX CSS follows the W3C standard, with slight modifications:

Inheritance & Cascading Rules: Styles apply top-down based on the Scene Graph hierarchy.

Global Styling: CSS applies to multiple UI components simultaneously.

Dynamic Style Updates: setStyle() can update styles at runtime.

Custom Fonts & Effects: @font-face and -fx-effect (shadow, blur, glow).

Theme Switching: Multiple stylesheets allow light/dark mode toggles dynamically.

-Animations and Effects

JavaFX animates UI components smoothly using transition classes:

Sequential & Parallel Transitions: Chain multiple animations using ParallelTransition and SequentialTransition.

Interpolation and Easing: Control motion effects (Interpolator.EASE_BOTH).

KeyFrame Animations: Use Timeline and KeyFrame for frame-by-frame animation.

Performance Considerations: Avoid CPU-heavy transitions by using hardware acceleration.